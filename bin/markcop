#!/bin/bash
#
# -----------------
# =    MARKCOP    =
# -----------------
#
# Markcop is your one-stop shop for Markdown enforcing.
#
# This script iterates through all of the .md files in `git ls-files` and checks
# that everything follows our markdown style guidelines at
# https://github.com/hackclub/meta/blob/master/markdown_style_guide.md
#
# It's still pretty janky, and will probably only work on Linux machines. If you
# run into any issues or have any comments/questions/concerns, please file an
# issue!

URL_REGEX='(https?|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'
HAS_ERROR=false
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'
CHECKS=(trailing_whitespace
        malformed_header
        header_missing_newline
        long_line
        missing_link
        eof_newline)

errors=''

IFS='
'

cat <<'EOF'
                                         _
                    _ __ ___   __ _ _ __| | _____ ___  _ __
                   | '_ ` _ \ / _` | '__| |/ / __/ _ \| '_ \
                   | | | | | | (_| | |  |   < (_| (_) | |_) |
                   |_| |_| |_|\__,_|_|  |_|\_\___\___/| .__/
                                                      |_|

================================================================================
                            Markcop is on patrol...
================================================================================


EOF

# Markdown checking functions

function trailing_whitespace {
  file_name="$1"
  trailing_whitespace_errors_in_file=false
  trailing_whitespace_regex='^.+\s{3,}$'
  for line in $(echo "$2" | grep -oP $trailing_whitespace_regex | sed -e 's/:/\t/'); do
    trailing_whitespace_errors_in_file=true
    line_num=$(echo "$line" | cut -f1)
    line_contents=$(echo $line | cut -f2)
    printf "${RED}x${NC}"
    errors="${errors}\n${file_name}:${line_num} has trailing whitespace!"
  done

  if [ $trailing_whitespace_errors_in_file = true ]; then
    return 1
  fi

  printf "${GREEN}.${NC}"
  return 0
}

function malformed_header {
  file_name="$1"
  malformed_header_in_file=false
  header_regex='^[0-9]+:#[^\{]*$'
  for line in $(echo "$2" | grep -oP $header_regex | sed -e 's/:/\t/'); do
    line_num=$(echo "$line" | cut -f1)
    line_contents=$(echo $line | cut -f2)
    # Check that there is a space between the # and the header
    header_missing_space_after_hashtag_regex='^\#{1,6}[^\ \#].*$'
    if [[ "$line_contents" =~ $header_missing_space_after_hashtag_regex ]]; then
      malformed_header_in_file=true
      errors="${errors}\n${file_name}:${line_num} doesn't have a space between the # and the text of the header!"
    fi
    # Check to see if a header is indented over 6 levels
    header_indented_over_6_levels_regex='^\#{7,}.*$'
    if [[ "$line_contents" =~ $header_indented_over_6_levels_regex ]]; then
      malformed_header_in_file=true
      errors="${errors}\n${file_name}:${line_num} is a header indented more than 6 levels!"
    fi
    # Check that the header doesn't end with a closing #
    header_ending_with_hashtag_regex='^.+\#[\ ]*$'
    if [[ "$line_contents" =~ $header_ending_with_hashtag_regex ]]; then
      malformed_header_in_file=true
      errors="${errors}\n${file_name}:${line_num} is a header with a closing #!"
    fi
  done

  if [ $malformed_header_in_file = true ]; then
    printf "${RED}x${NC}"
    return 1
  fi

  printf "${GREEN}.${NC}"
  return 0
}

function header_missing_newline {
  file_name="$1"
  header_missing_newline_in_file=false
  # Find headers with non-empty trailing or leading lines
  header_without_trailing_or_leading_line_regex="([0-9]+\:\#.+$\n[0-9]+\:.+|[0-9]+\:.+\n^[0-9]+\:\#.+)"
  for line in $(echo "$2" | grep -zoP $header_without_trailing_or_leading_line_regex); do
    line_number_regex="[0-9]+(?=\:\#)"
    line_num=$(echo $line | grep -oP $line_number_regex)
    if [[ -n "$line_num" ]]; then
      header_missing_newline_in_file=true
      errors="${errors}\n${file_name}:${line_num} is missing a newline before or after the heading!"
    fi
  done

  if [ $header_missing_newline_in_file = true ]; then
    printf "${RED}x${NC}"
    return 1
  fi

  printf "${GREEN}.${NC}"
  return 0
}

function long_line {
  file_name="$1"
  long_line_in_file=false
  long_line_regex='^[0-9]+:[^\|].{80,}[^\|]$'
  for line in $(echo "$2" | grep -oP $long_line_regex | sed -e 's/:/\t/'); do
    line_contents=$(echo $line | cut -f2)
    # Check to make sure the line doesn't contain a link or HTML comment
    html_comment_regex='^<!--.*-->$'
    markdown_link_at_end_of_line_regex='\[.*\]\(.*\)\W*$'
    if [[ ! $line_contents =~ $URL_REGEX && ! $line_contents =~ $html_comment_regex && ! $line_contents =~ $markdown_link_at_end_of_line_regex ]]; then
      line_num=$(echo "$line" | cut -f1)
      long_line_in_file=true
      errors="${errors}\n${file_name}:${line_num} is over 80 chars!"
    fi
  done

  if [ $long_line_in_file = true ]; then
    printf "${RED}x${NC}"
    return 1
  fi

  printf "${GREEN}.${NC}"
  return 0
}

function missing_link {
  file_name="$1"
  link_line_regex='!?\[([^\]]*)\]\(([^)"]+)(?: \"([^\"]+)\")?\)'
  for line in $(echo "$2" | grep -noP $link_line_regex); do
    line_num=$(echo $line | cut -f1)
    dir=$(dirname "$file_name")
    link_dest=$(echo $line | sed 's/.*\[.*\](\(.*\))/\1/')
    broken_link=true

    # Only check if the link is not a URL and if it's not empty
    if [[ ( ! $link_dest =~ $URL_REGEX ) ]]; then
      link_dest_file=$(echo $link_dest | sed "s/#.*$//") # 'file.md' <- 'file.md#heading'
      link_dest_heading=$(echo $link_dest | grep -o '#.*$') # '#heading' <- 'file.md#heading'
      linked_path=$(readlink -f "$dir/$link_dest_file") # '/home/user/proj/file.md'

      # If there's no link_dest_heading (the '#heading' part of 'file.md#heading')
      if [[ -z "$link_dest_heading" ]]; then
        # Check if the linked path is either an existing file or directory
        if [[ ( -f "$linked_path" ) || ( -d "$linked_path" ) ]]; then
          broken_link=false
        fi
      else
        file_to_check=$file_name

        # If there's a filename in the link (the 'file.md' part of 'file.md#heading')
        if [[ ! -z "$link_dest_file" ]]; then
          file_to_check=$linked_path
        fi

        # '#my-heading' -> 'my heading'
        stripped_heading=$(echo $link_dest_heading | sed -e 's/#//' -e 's/-/ /g')

        for match in $(
                      cat $file_to_check |
                        grep -i "^#\+" | # only headings
                        sed 's/-/ /g' | # replace dashes with spaces
                        tr -d '[:punct:]' | # remove all punctuation
                        sed -e 's/^ \+//' -e 's/ \+$//' -e 's/  \+/ /g' | # strip extra spaces
                        grep -io "^$stripped_heading\$"
                    ); do
          broken_link=false
        done
      fi
    else # if the link is a URL
      broken_link=false
    fi

    if [ $broken_link = true ]; then
      printf "${RED}x${NC}"
      errors="${errors}\n${file}:${line_num} '${link_dest}' is not a valid link!"
    else
      printf "${GREEN}.${NC}"
    fi

  done
}

function eof_newline {
  local file_name="$1"
  local last_byte=$(tail -c 1 $file_name)

  # If the last byte is an empty string, then there's a newline at the end of
  # the file. If not, the file doesn't end in a newline.
  if [ "$last_byte" != "" ]; then
    printf "${RED}x${NC}"
    errors="${errors}\n${file} doesn't end in a newline"
  else
    printf "${GREEN}.${NC}"
  fi
}

# Run through each function in the CHECKS array, passing each $file and
# $contents
for check in "${CHECKS[@]}"; do
  printf "\n\nRunning check: $check...\n"
  for file in $(git ls-files | grep '\.md$'); do
    content=$(grep -n "" $file | perl -0777 -pe 's/[0-9]+\:```.*?```//gs')
    # $content is in the format file:line_number:line
    $check "$file" "$content"
  done
done

>&2 printf "\n\n$errors\n"

if [ -n "$errors" ]; then
  exit 1
fi
